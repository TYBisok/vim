# 内容变更历史

Vim 7.0 添加了一个叫做 **Undo Branches** 的新特性，主要用来以树的形式记录内容变更历史，以便于在修改内容之后进行撤销（undo）或者重做（redo）的操作。

Vim 采用树形结构来存储变更历史，而不是使用队列的方式来存储变更历史。除了第一次修改之外的其他所有修改，都有一个父节点；且该修改也会保存为当前树形结构的一个变更节点，该节点保存了此次修改的时间以及修改内容。

假设有如下按键操作：

```viml
ifoo<esc>
obar<esc>
obaz<esc>
u
oquux<exc>
```

在 Vim 的变更历史树中，存储的树形结构如下：


```
     foo(1)
       /
    bar(2)
   /      \
baz(3)   quux(4)
```

## undo vs redo 的两种方式

在遍历变更历史时，有两种方式，一种是 按分支遍历，一种是 按时间遍历。

### 按时间遍历

如果是使用按时间遍历的方式，则第一次回退时，会回退到第三次修改，即最后一行的内容为 `baz`；再回退一次最后一行的内容为 `bar`；完全按照内容修改的时间顺序前进或者后退。

快捷键：

* `g-`：后退到上一次变更
* `[count]g-`: 后退到 `[count]` 次之前的修改
* `:earlier`: 同 `g-`
* `g+`: 同 `g-`，方向相反
* `[count]g+`: 同 `[count]g-`，方向相反
* `:later`: 同 `:earlier`， 方向相反

### 按分支遍历

该遍历方式每次回退都回到其父节点，每次前进都前进到回退之前的子节点。所以，使用分支遍历时，永远不会遍历到某个节点的兄弟节点，只能通过时间遍历的方式或者时间遍历+分支遍历的方式才能遍历到当前节点的兄弟节点。

以上面的树形结构为例，第一次回退不会回到第三次修改的地方，而是回退到第二次修改，即第四次修改 `quux` 的父节点 `bar` 的位置；再次回退则回到 `foo` 的位置；此时前进会前进到 `bar` 的位置，再前进则前进到 `quux` 的位置；使用分支遍历时，永远不会遍历到 `baz` 所在的分支。

**注：按分支遍历是 Vim 的默认方式**

快捷键：

* `u`：回退到上一次变更
* `:undo`：同 `u`
* `<Ctrl>-r`：前进到下一次变更
* `:redo`： 同 `<Ctrl>-r`

## 查看帮助信息

可以通过 `:help new-undo-branches` 或者 `:help undo-tree` 这两条命令查看更多帮助信息。

## 其他

对于变更历史管理，可以使用插件 [undotree](./plugin/undotree.md) 进行可视化的管理。

## 参考

* [undotree](https://github.com/mbbill/undotree#description)
* [内容变更历史记录](https://github.com/wsdjeg/vim-galore-zh_cn#%E5%86%85%E5%AE%B9%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95)

## Author 🦃

* [GitHub](https://github.com/Tao-Quixote)
* Email: <web.taox@gmail.com>
